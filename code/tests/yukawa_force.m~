% Calculate force and torque for multiple bodies

x1   = [];
x2   = [];
tau1 = [];
tau2 = [];
nu1  = [];
nu2  = [];
cur  = [];
dS   = [];
uD   = [];

x1_nbr  = [];
x2_nbr  = [];
nu1_nbr = [];
nu2_nbr = [];
dS_nbr  = [];

for p = 1:Nb

  [x1_p x2_p tau1_p tau2_p nu1_p nu2_p cur_p dS_p] = particle_curve(a(p), pc(p,1), pc(p,2), orn(p), str2func(string(typ(p))), N);

  x1   = [x1   x1_p];
  x2   = [x2   x2_p];      
  tau1 = [tau1 tau1_p];
  tau2 = [tau2 tau2_p];
  nu1  = [nu1  nu1_p];
  nu2  = [nu2  nu2_p];
  cur  = [cur  cur_p];
  dS   = [dS   dS_p];

  tmp  = atan2(x2_p - pc(p,2), x1_p - pc(p,1)); 
  uD_p = 0.5*(1 + cos( tmp - orn(p) ));
  uD   = [uD uD_p];    

  [x1_p x2_p tau1_p tau2_p nu1_p nu2_p cur_p dS_p] = particle_curve(a(p)+10*max(dS(:,p)), pc(p,1), pc(p,2), orn(p), str2func(string(typ(p))), N);

  x1_nbr  = [x1_nbr  x1_p];
  x2_nbr  = [x2_nbr  x2_p];       
  nu1_nbr = [nu1_nbr nu1_p];
  nu2_nbr = [nu2_nbr nu2_p];  
  dS_nbr  = [dS_nbr  dS_p];
  
end

clf

set(gcf,'position',[100,100,500,500])

% a cartesian grid for visualizaion 
[X1, X2] = meshgrid(linspace(min(x1,[],'all')-2, max(x1,[],'all')+2, 201), linspace(min(x2,[],'all')-2, max(x2,[],'all')+2, 201));

% calculate some cutoffs 
COFF      = 0*X1;
COFF_soft = 0*X1;
for p = 1:Nb

    [z z_soft] = CUT_OFF(X1, X2, pc(p,1), pc(p,2), a(p), orn(p), str2func(string(typ(p))), 6*mean(dS(:,p)));

    COFF      = COFF + z;
    COFF_soft = COFF_soft + z_soft;      

end    

COFF      = 1 - COFF;
COFF_soft = 1 - (COFF_soft>0);

plot(x1, x2, 'k');
hold on
plot(x1_nbr, x2_nbr, 'm');
plot3(x1,x2,uD,'r','linewidth',2)
hold off
axis equal
view(3)
pause(0.1)

%Setting up linear system

K = zeros(N*Nb,N*Nb);

% vectorized version of the above 
for q = 1:Nb
    for j = 1:N

        r1 = x1(j,q) - x1(:);
        r2 = x2(j,q) - x2(:);
        r  = sqrt( r1.^2 + r2.^2 );

        Lnu = ( r1.*nu1(j,q) + r2.*nu2(j,q) )./r.^2;

        J = (q-1)*N + j;
        K(:, J) = -1/(2*pi)*(r/rho).*besselk(1, r/rho).*Lnu*dS(j,q);

        K(J, J) = cur(j,q)*dS(j,q)/(4*pi); %removable singularity 
        
    end
end

RHS = reshape(uD,N*Nb,1);
h   = (1/2*eye(N*Nb) + K)\RHS;
h   = reshape(h, N, Nb);

%Dh = evalDL(X1, X2, Nb, N, x1, x2, nu1, nu2, dS, rho, h);
%surf(X1,X2, Dh.*COFF_soft,'edgecolor','none')

[F1, F2, Tq] = evalForces(Nb, N, x1_nbr, x2_nbr, nu1_nbr, nu2_nbr, dS_nbr, x1, x2, nu1, nu2, dS, rho, h, pc);

[[F1, F2, Tq];
sum([F1 F2 Tq])]

%END 



function [F1, F2, Tq] = evalForces(Nb, N, x1_nbr, x2_nbr, nu1_nbr, nu2_nbr, dS_nbr, x1, x2, nu1, nu2, dS, rho, h, pc)

% evaluates the force and torque on the particles 

% x1, x2 : parametrization of particle curves
% x1_nbr, x2_nbr : parametrization of nearby outer curve; the stress tensor T is divergence free and so we
%            can evaluate force and torque on nearby curves, versus directly on particle curve 

F1 = zeros(Nb,1);
F2 = zeros(Nb,1);
Tq = zeros(Nb,1);

u            = evalDL(    x1_nbr, x2_nbr, Nb, N, x1, x2, nu1, nu2, dS, rho, h);
[u_x1, u_x2] = evalGradDL(x1_nbr, x2_nbr, Nb, N, x1, x2, nu1, nu2, dS, rho, h);

%{
subplot(111) %reset single plot
hold off
plot(x1, x2, 'k', 'linewidth', 2);
hold on
plot(x1_nbr, x2_nbr, 'r');
quiver(x1_nbr, x2_nbr, u_x1, u_x2,'b');

hold off
axis equal;
%}

T11 = 1/rho*u.^2 + 2*rho*( 0.5*(u_x1.^2 + u_x2.^2) - u_x1.*u_x1 );
T12 =              2*rho*(                         - u_x1.*u_x2 );
T21 = T12;
T22 = 1/rho*u.^2 + 2*rho*( 0.5*(u_x1.^2 + u_x2.^2) - u_x2.*u_x2 );

for p = 1:Nb

    for i = 1:N

        F1(p) = F1(p) + (T11(i,p)*nu1_nbr(i,p) + T12(i,p)*nu2_nbr(i,p))*dS_nbr(i,p);
        
        F2(p) = F2(p) + (T21(i,p)*nu1_nbr(i,p) + T22(i,p)*nu2_nbr(i,p))*dS_nbr(i,p);
        
        Tq(p) = Tq(p) + ( x1_nbr(i,p)*(T21(i,p)*nu1_nbr(i,p) + T22(i,p)*nu2_nbr(i,p)) ...
                        - x2_nbr(i,p)*(T11(i,p)*nu1_nbr(i,p) + T12(i,p)*nu2_nbr(i,p)) ) * dS_nbr(i,p);
                        
    end

end

end


function Dh = evalDL(X1, X2, Nb, N, x1, x2, nu1, nu2, dS, rho, h)

    % evaluates double layer potential at (X1, X2)

    Dh = 0*X1;
    for q = 1:Nb
        for j = 1:N

            r1 = X1 - x1(j,q); r2 = X2 - x2(j,q);
            r = sqrt( r1.^2 + r2.^2 );                        
            rdotnu = r1.*nu1(j,q) + r2.*nu2(j,q);            
            K1 = besselk(1, r/rho);
            %using r = x - y; hence lack of minus below
            Dh = Dh + 1/(2*pi)*(r/rho).*K1.*rdotnu./r.^2.*dS(j,q).*h(j,q);
            
        end
    end

end


function [Dh_X1, Dh_X2] = evalGradDL(X1, X2, Nb, N, x1, x2, nu1, nu2, dS, rho, h)
    % evaluates gradient of double layer potential at (X1, X2)
    
    Dh_X1 = 0*X1;
    Dh_X2 = 0*X1;    

    for q = 1:Nb
        for j = 1:N

            r1 = X1 - x1(j,q);
            r2 = X2 - x2(j,q);

            rdotnu = r1.*nu1(j,q) + r2.*nu2(j,q);

            r  = sqrt( r1.^2 + r2.^2 );
            
            K0 = besselk(0, r/rho);
            K1 = besselk(1, r/rho);
            K2 = besselk(2, r/rho);
            dK1 = -0.5*(K0 + K2); %see identity https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/20/01/02/
            
%           Dh = Dh + 1/(2*pi)*(r/rho).*K1.*rdotnu./r.^2*dsD(q)*h(q,j);
            Dh_X1 = Dh_X1 + 1/(2*pi)*( ...
                  + r1./(r*rho).*K1.*rdotnu./r.^2 ...
                  + (r/rho).*dK1.*r1./(r*rho).*rdotnu./r.^2 ...
                  + (r/rho).*K1.*(1./r.^2).*(nu1(j,q) - 2*r1.*rdotnu./r.^2) ...
                  )*dS(j,q)*h(j,q);

            Dh_X2 = Dh_X2 + 1/(2*pi)*( ...
                  + r2./(r*rho).*K1.*rdotnu./r.^2 ...
                  + (r/rho).*dK1.*r2./(r*rho).*rdotnu./r.^2 ...
                  + (r/rho).*K1.*(1./r.^2).*(nu2(j,q) - 2*r2.*rdotnu./r.^2) ...
                  )*dS(j,q)*h(j,q);

        end
    end

end

function [u, u_x1, u_x2] = manufcr_sol(X1, X2, Nb, pc1, pc2, rho, level)

  P = 2; %order of Fourier series (order starts at 0)

  %Some cosine coefficients 
  A = [0.9569    0.7593    0.4633    0.1636    0.1536    0.8092    0.5464    0.0205    0.9211    0.7519;
       0.9357    0.7406    0.2122    0.6660    0.9535    0.7486    0.3989    0.9237    0.7947    0.2287;
       0.4579    0.7437    0.0985    0.8944    0.5409    0.1202    0.4151    0.6537    0.5774    0.0642;
       0.2405    0.1059    0.8236    0.5166    0.6797    0.5250    0.1807    0.9326    0.4400    0.7673;
       0         0         0         0         0         0         0         0         0         0     ];


  u = 0*X1;
  u_x1 = 0*X1;   
  u_x2 = 0*X1;
  CUTOFF  = 1+0*X1;
  CUTOFF0 = 1+0*X1;
  
  for p = 1:Nb

    R = sqrt( ( X1-pc1(p) ).^2 + ( X2-pc2(p) ).^2 );
    T = atan2( X2-pc2(p), X1-pc1(p) );

    R0 = 0.6;

    for n = 0:P
    
        u  = u  + A(p,n+1)*besselk(n, R/rho)./besselk(n,R0/rho).*cos(n*T);
        
    end    

  end

  % numerical differentiation; recursively call function one level. 
  if level == 0
    h = 1e-5;
    u_x1 = (manufcr_sol(X1 + h, X2, Nb, pc1, pc2, rho, 1) - manufcr_sol(X1 - h, X2, Nb, pc1, pc2, rho, 1))/(2*h);
    u_x2 = (manufcr_sol(X1, X2 + h, Nb, pc1, pc2, rho, 1) - manufcr_sol(X1, X2 - h, Nb, pc1, pc2, rho, 1))/(2*h);  
  end
  
end


function [x1 x2 tau1 tau2 nu1 nu2 cur dS] = particle_curve(a, pc1, pc2, orn, param_fun, N)

% a   : characteristic radius
% pc  : particle center
% orn : orientation 
% typ : type, eg circle, ellipse, star, etc
% N   : numper of points per particle curve

T  = linspace(0, 2*pi, N+1)';
T  = T(1:end-1);
dT = T(2) - T(1);

[X1,  X2,  dX1,  dX2, ddX1, ddX2]  = param_fun(a, T  );
V   = sqrt( dX1.^2 + dX2.^2 );
%dT1 = 1./V.*( ddX1 - (ddX1.*dX1 + ddX2.*dX2).*dX1./V.^2)
%dT2 = 1./V.*( ddX1 - (ddX1.*dX1 + ddX2.*dX2).*dX1./V.^2)

cur = (ddX1.*dX2 - ddX2.*dX1)./V.^3;

% Perform final assignments along with rigid body motion 
x1 = pc1 + cos(orn)*X1 - sin(orn)*X2;
x2 = pc2 + sin(orn)*X1 + cos(orn)*X2;

dx1 = cos(orn)*dX1 - sin(orn)*dX2;
dx2 = sin(orn)*dX1 + cos(orn)*dX2;

tau1 = dx1./V; tau2 = dx2./V; 
nu1  = tau2;   nu2  = -tau1; 

dS   = V*dT; %dS*ones(size(x1));

% confirmation for ellipse only
% b = 0.05*a;
% e = sqrt(1-b^2/a^2);
% [K,E] = ellipke(e^2);
% [s(end) - 4*a*E]

%plot(t, s, T, S,'.');

%hold off
%plot(x1, x2);
%hold on
%plot3(x1, x2, cur);
%quiver(x1, x2, dx1./V, dx2./V);
%quiver(x1, x2, dT1, dT2);
%axis equal
%hold off
%pause
%return

end



function [x1, x2, dx1, dx2, ddx1, ddx2] = star_shape(a, t)

fac = 0.3;
P   = 5;

r   = (1 + fac*cos(P*t));
dr  = -P*fac*sin(P*t);
ddr = -P^2*fac*cos(P*t);

x1  =   a*cos(t).*r;
x2  =   a*sin(t).*r;

dx1 = - a*sin(t).*r + a*cos(t).*dr;
dx2 = + a*cos(t).*r + a*sin(t).*dr;

ddx1 = - a*cos(t).*r - 2*a*sin(t).*dr + a*cos(t).*ddr;
ddx2 = - a*sin(t).*r + 2*a*cos(t).*dr + a*sin(t).*ddr;

end

function [x1, x2, dx1, dx2, ddx1, ddx2] = bean_shape(a, t)

s = (t-pi)/2;

r   =     cos(s).^3 + sin(s).^3;
dr  =  -3*cos(s).^2.*sin(s)/2 + 3*sin(s).^2.*cos(s)/2;
ddr =  +6*cos(s).*sin(s).^2/4 - 3*cos(s).^3/4 + 6*sin(s).*cos(s).^2/4 - 3*sin(s).^3/4; 

x1  =   a*cos(s).*r - a*0.25;
x2  =   a*sin(s).*r - a*0.25;

dx1 = - a*sin(s)/2.*r + a*cos(s).*dr;
dx2 = + a*cos(s)/2.*r + a*sin(s).*dr;

ddx1 = - a*cos(s)/4.*r - 2*a*sin(s)/2.*dr + a*cos(s).*ddr;
ddx2 = - a*sin(s)/4.*r + 2*a*cos(s)/2.*dr + a*sin(s).*ddr;

end


function [z z_soft] = CUT_OFF(X1, X2, pc1, pc2, a, orn, param_fun, tol)

% decide whether or not a point X1, X2 lies in the curve or not
% transform point back to primal coordinates

% w is just a cutoff if too close to the curve set by tol

tmp1 = cos(-orn)*(X1-pc1) - sin(-orn)*(X2-pc2);
tmp2 = sin(-orn)*(X1-pc1) + cos(-orn)*(X2-pc2);

X1 = tmp1; X2 = tmp2;

t = linspace(0, 2*pi, 200);
dt = t(2) - t(1);
[y1 y2 dy1 dy2] = param_fun(a, t);

ds  = sqrt(dy1.^2 + dy2.^2);
nu1 = dy2./ds; nu2 = -dy1./ds;

z = 0*X1;
D = sqrt(  (X1 - y1(10)).^2 + (X2 - y2(10)).^2 );

for i = 1:length(t)
    r1 = X1 - y1(i); r2 = X2 - y2(i);
    z = z + (r1.*nu1(i) + r2.*nu2(i))./(r1.^2 + r2.^2).*ds(i)*dt/(-2*pi);
    D = min(D, sqrt( r1.^2 + r2.^2 ) );
end 

z = z > 0.5;

z_soft = D < tol | z;

end



